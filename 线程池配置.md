# JUC
CPU密集型任务
 尽量使用较小的线程池，一般为CPU核心数+1。 因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，会造成CPU过度切换。

IO密集型任务
 可以使用稍大的线程池，一般为2*CPU核心数。 IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候有其他线程去处理别的任务，充分利用CPU时间。

混合型任务
 可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。
 因为如果划分之后两个任务执行时间有数据级的差距，那么拆分没有意义。
 因为先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。

配置

  \* 需要根据几个值来决定            

- tasks ：每秒的任务数，假设为500~1000 

- taskcost：每个任务花费时间，假设为0.1s  

- responsetime：系统允许容忍的最大响应时间，假设为1s      

  做几个计算      

  corePoolSize = 每秒需要多少个线程处理？                

  *threadcount = tasks/(1/taskcost) =tasks*taskcout =  (500~1000)*0.1 = 50~100 个线程。  *corePoolSize设置应该大于50               

  根据8020原则，如果80%的每秒任务数小于800，那么corePoolSize设置为80即可

  \- queueCapacity （等待队列容量）= (coreSizePool/taskcost)*responsetime                

  * 计算可得 queueCapacity = 80/0.1*1 = 80。意思是队列里的线程可以等待1s，超过了的需要新开线程来执行               

  * 切记不能设置为Integer.MAX_VALUE，这样队列会很大，线程数只会保持在corePoolSize大小，当任务陡增时，不能新开线程来执行，响应时间会随之陡增。

    \- maxPoolSize = (max(tasks)- queueCapacity)/(1/taskcost)                

    计算可得 maxPoolSize = (1000-80)/10 = 92

    (最大任务数-队列容量）/每个线程每秒处理能力 = 最大线程数